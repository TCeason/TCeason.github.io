<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>mysqldump 源码分析</title>
    <url>/2020/11/15/mysqldump-%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>mysqldump 作为 MySQL 源生支持的逻辑复制工具自从上古时代就已经被DBA广泛使用，时至今日，很多人都依然在用他作为轻量级数据库的备份工具。</p>
<p>虽然在 MySQL 复制工具中 mysqldump 具有 OG 地位，但是不可否认在当代社会，<code>单线程复制</code>，<code>逻辑导出</code>完全无法 cover 大部分的备份需求场景，比如对于近TB级别的数据如果用mysqldump导出并不落盘的直接写入到其他节点中，可能要以天为时间计量单位去计算一次恢复耗时。试问，谁能忍受我们常用的网站突然某一天弹出一个提示框：<code>今天网站数据迁移，请后天进行访问。</code> </p>
<p>而今天本着对时代的缅怀，我想再好好看看 <code>mysqldump</code> 是如何实现的。而快速了解基本实现逻辑，最好的莫过于从他刚刚出生不久时候开始。接下来，我们穿越回上古，看看他年轻时候的样子吧。</p>
<a id="more"></a>

<h2 id="2-源码分析"><a href="#2-源码分析" class="headerlink" title="2. 源码分析"></a>2. 源码分析</h2><h3 id="2-1-源码版本"><a href="#2-1-源码版本" class="headerlink" title="2.1 源码版本"></a>2.1 源码版本</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git remote -vv </span><br><span class="line">origin	https:&#x2F;&#x2F;github.com&#x2F;TCeason&#x2F;MySQL-4.1.21.git (fetch)</span><br><span class="line">origin	https:&#x2F;&#x2F;github.com&#x2F;TCeason&#x2F;MySQL-4.1.21.git (push)</span><br><span class="line"></span><br><span class="line">$ git log -1|more</span><br><span class="line">commit 1a6487c79b109dc944191dbaff1fe077290c1af9</span><br><span class="line"></span><br><span class="line">$ ls client&#x2F;mysqldump.c </span><br><span class="line">client&#x2F;mysqldump.c</span><br></pre></td></tr></table></figure>

<p>在本版本中，mysqldump 作为一个客户端命令，位于 <code>client/mysqldump.c</code>，仅仅有两千行代码。</p>
<p>而有意思的是，在 4.0.10 版本中，只有一千多行代码，也许是因为4.1 相对于 4.0 增加了隔离级别的概念，因此功能相对丰富了。而在 5.7 中已经接近万行了，也许未来会是一个破万的C代码。</p>
<p>从是 4.0 版本到 5.7 版本，他就这么静静的矗立在这里，即使会被时代渐渐抛弃，也依然坚挺。不得不说，respect！！</p>
<h3 id="2-3-分析"><a href="#2-3-分析" class="headerlink" title="2.3 分析"></a>2.3 分析</h3><p>下面的分析仅仅基于目前 MySQL DB Engine 的顶流 INNODB。</p>
<p><a href="https://github.com/TCeason/MySQL-4.1.21/blob/main/client/mysqldump.c#L2638" target="_blank" rel="noopener">main方法：</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int main(int argc, char **argv)</span><br><span class="line">&#123;</span><br><span class="line">  compatible_mode_normal_str[0]&#x3D; 0;</span><br><span class="line">  default_charset&#x3D; (char *)mysql_universal_client_charset;</span><br><span class="line">  bzero((char*) &amp;ignore_table, sizeof(ignore_table));</span><br><span class="line"></span><br><span class="line">  MY_INIT(&quot;mysqldump&quot;);</span><br><span class="line">  if (get_options(&amp;argc, &amp;argv))</span><br><span class="line">    ...</span><br><span class="line"> </span><br><span class="line">  if (dbConnect(current_host, current_user, opt_password))</span><br><span class="line">    exit(EX_MYSQLERR);</span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  if ((opt_lock_all_tables || opt_master_data) &amp;&amp;</span><br><span class="line">      do_flush_tables_read_lock(sock))</span><br><span class="line">    goto err;</span><br><span class="line">  if (opt_single_transaction &amp;&amp; start_transaction(sock, test(opt_master_data)))</span><br><span class="line">      goto err;</span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line">  </span><br><span class="line">  if (opt_lock_all_tables || opt_master_data)</span><br><span class="line">  &#123;</span><br><span class="line">    if (flush_logs &amp;&amp; mysql_refresh(sock, REFRESH_LOG))</span><br><span class="line">      goto err;</span><br><span class="line">    flush_logs&#x3D; 0; &#x2F;* not anymore; that would not be sensible *&#x2F;</span><br><span class="line">  &#125;</span><br><span class="line">  if (opt_master_data &amp;&amp; do_show_master_status(sock))</span><br><span class="line">    goto err;</span><br><span class="line">  if (opt_single_transaction &amp;&amp; do_unlock_tables(sock)) &#x2F;* unlock but no commit! *&#x2F;</span><br><span class="line">    goto err;</span><br><span class="line"></span><br><span class="line">  if (opt_alldbs)</span><br><span class="line">    dump_all_databases();</span><br><span class="line">  else if (argc &gt; 1 &amp;&amp; !opt_databases)</span><br><span class="line">  &#123;</span><br><span class="line">    &#x2F;* Only one database and selected table(s) *&#x2F;</span><br><span class="line">    dump_selected_tables(*argv, (argv + 1), (argc - 1));</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    &#x2F;* One or more databases, all tables *&#x2F;</span><br><span class="line">    dump_databases(argv);</span><br><span class="line">  &#125;</span><br><span class="line">#ifdef HAVE_SMEM</span><br><span class="line">  my_free(shared_memory_base_name,MYF(MY_ALLOW_ZERO_PTR));</span><br><span class="line">#endif</span><br><span class="line">  &#x2F;*</span><br><span class="line">    No reason to explicitely COMMIT the transaction, neither to explicitely</span><br><span class="line">    UNLOCK TABLES: these will be automatically be done by the server when we</span><br><span class="line">    disconnect now. Saves some code here, some network trips, adds nothing to</span><br><span class="line">    server.</span><br><span class="line">  *&#x2F;</span><br><span class="line">err:</span><br><span class="line">  dbDisconnect(current_host);</span><br><span class="line">  if (!path)</span><br><span class="line">    write_footer(md_result_file);</span><br><span class="line">  if (md_result_file !&#x3D; stdout)</span><br><span class="line">    my_fclose(md_result_file, MYF(0));</span><br><span class="line">  my_free(opt_password, MYF(MY_ALLOW_ZERO_PTR));</span><br><span class="line">  if (hash_inited(&amp;ignore_table))</span><br><span class="line">    hash_free(&amp;ignore_table);</span><br><span class="line">  if (extended_insert)</span><br><span class="line">    dynstr_free(&amp;extended_row);</span><br><span class="line">  if (insert_pat_inited)</span><br><span class="line">    dynstr_free(&amp;insert_pat);</span><br><span class="line">  my_end(0);</span><br><span class="line">  return(first_error);</span><br><span class="line">&#125; &#x2F;* main *&#x2F;</span><br></pre></td></tr></table></figure>

<h4 id="2-3-1-get-options"><a href="#2-3-1-get-options" class="headerlink" title="2.3.1.  get_options"></a>2.3.1.  get_options</h4><p>主要是用来检查选项设置是否合理。比如当指定 –single-transaction =1 的同时还指定了 –lock-all-tables = 1 这时，由于两者的行为是冲突的，就会直接报错。</p>
<blockquote>
<ul>
<li><p>–lock-all-tables<br>Locks all tables across all databases. This<br>is achieved by taking a global read lock for the duration of the whole </p>
</li>
<li><p>–single-transaction<br>single-transaction is specified too (in which case a<br>global read lock is only taken a short time at the beginning of the dump<br>don’t forget to read about –single-transaction below). In all cases<br>any action on logs will happen at the exact moment of the dump.dump.</p>
</li>
<li><p>–master-data<br>This causes the binary log position and filename to be appended to the<br>output. If equal to 1, will print it as a CHANGE MASTER command; if equal<br> to 2, that command will be prefixed with a comment symbol.<br>This option will turn –lock-all-tables on, unless<br>–single-transaction is specified too (in which case a<br>global read lock is only taken a short time at the beginning of the dump<br>don’t forget to read about –single-transaction below). In all cases<br>any action on logs will happen at the exact moment of the dump.<br>Option automatically turns –lock-tables off.</p>
</li>
</ul>
</blockquote>
<p>其实，从参数解释来看，我们在生产中大多数情况下，应该要设置–master-data=1, –single-transaction =1; 而当 –master-data=1 时，–lock-all-tables 会被该函数自动处理成 !single-transaction。</p>
<p>接下来的流程分析，也将会按照这三个配置进行下去。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--master-data &#x3D; 1;</span><br><span class="line">--single-transaction &#x3D; 1; </span><br><span class="line">--lock-all-tables &#x3D; 0;</span><br></pre></td></tr></table></figure>

<h4 id="2-3-2-dbConnect"><a href="#2-3-2-dbConnect" class="headerlink" title="2.3.2. dbConnect"></a>2.3.2. dbConnect</h4><p>顾名思义，主要是给 MYSQL 类型的 sock 赋值。并选择。核心内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static MYSQL mysql_connection,*sock&#x3D;0;</span><br><span class="line"></span><br><span class="line">static int dbConnect(char *host, char *user,char *passwd)</span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">	mysql_init(&amp;mysql_connection);</span><br><span class="line">	mysql_options(&amp;mysql_connection, MYSQL_SET_CHARSET_NAME, default_charset);</span><br><span class="line">	if (!(sock&#x3D; mysql_real_connect(&amp;mysql_connection,host,user,passwd,</span><br><span class="line">	       NULL,opt_mysql_port,opt_mysql_unix_port,</span><br><span class="line">	       0)))</span><br><span class="line">	&#123;</span><br><span class="line">	  DBerror(&amp;mysql_connection, &quot;when trying to connect&quot;);</span><br><span class="line">	  return 1;</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-3-3-FTWRL"><a href="#2-3-3-FTWRL" class="headerlink" title="2.3.3. FTWRL"></a>2.3.3. FTWRL</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((opt_lock_all_tables || opt_master_data) &amp;&amp;</span><br><span class="line">   do_flush_tables_read_lock(sock))</span><br><span class="line"> <span class="keyword">goto</span> err;</span><br></pre></td></tr></table></figure>

<p>在这一步中，由于需要记录当前的binlog位点，因此，需要对所有的表加锁，主要执行了下面两个 SQL 。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FLUSH TABLES；</span><br><span class="line">FLUSH TABLES WITH READ LOCK;</span><br></pre></td></tr></table></figure>

<p>直接加 FTWRL 其实就可以获得当前 Server 的一致位点，但是，为了防止当前有 long query运行，导致长时间锁住 Server，先通过 Flush tables 等待 long query 结束，然后快速对整个 DB 加锁。但是，如果刚好在两个查询执行期间有 long query，就无能为力了。</p>
<p><a href="https://dev.mysql.com/doc/internals/en/flush-tables.html" target="_blank" rel="noopener">FLUSH TABLES传送门</a><br><a href="https://dev.mysql.com/doc/refman/5.7/en/flush.html#flush-tables-with-read-lock" target="_blank" rel="noopener">FTWRL传送门</a></p>
<h4 id="2-3-4-start-transaction"><a href="#2-3-4-start-transaction" class="headerlink" title="2.3.4. start_transaction"></a>2.3.4. start_transaction</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (opt_single_transaction &amp;&amp; start_transaction(sock, test(opt_master_data)))</span><br><span class="line">     <span class="keyword">goto</span> err;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">start_transaction</span><span class="params">(MYSQL *mysql_con, my_bool consistent_read_now)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (mysql_query_with_error_report(mysql_con, <span class="number">0</span>,</span><br><span class="line">                                        <span class="string">"SET SESSION TRANSACTION ISOLATION "</span></span><br><span class="line">                                        <span class="string">"LEVEL REPEATABLE READ"</span>) ||</span><br><span class="line">          mysql_query_with_error_report(mysql_con, <span class="number">0</span>,</span><br><span class="line">                                        consistent_read_now ?</span><br><span class="line">                                        <span class="string">"START TRANSACTION "</span></span><br><span class="line">                                        <span class="string">"WITH CONSISTENT SNAPSHOT"</span> :</span><br><span class="line">                                        <span class="string">"BEGIN"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在代码里面有一个 test(opt_master_data)，其实是这样实现的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define MY_TEST(a)		((a) ? 1 : 0)</span><br></pre></td></tr></table></figure>

<p>因此，执行的sql是将隔离级别设置为RR，并且开启一致性事务。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">SESSION</span> <span class="keyword">TRANSACTION</span> <span class="keyword">ISOLATION</span> <span class="keyword">LEVEL</span> REPEATABLE <span class="keyword">READ</span>;</span><br><span class="line"><span class="keyword">START</span> <span class="keyword">TRANSACTION</span> <span class="keyword">WITH</span> <span class="keyword">CONSISTENT</span> <span class="keyword">SNAPSHOT</span>;</span><br></pre></td></tr></table></figure>

<p><a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-transaction-isolation-levels.html" target="_blank" rel="noopener">事务隔离级别传送门</a><br><a href="https://dev.mysql.com/doc/refman/5.7/en/commit.html" target="_blank" rel="noopener">一致性事务传送门</a></p>
<h4 id="2-3-5-Refresh-logs"><a href="#2-3-5-Refresh-logs" class="headerlink" title="2.3.5. Refresh logs"></a>2.3.5. Refresh logs</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (opt_lock_all_tables || opt_master_data)</span><br><span class="line"> &#123;</span><br><span class="line">   <span class="keyword">if</span> (flush_logs &amp;&amp; mysql_refresh(sock, REFRESH_LOG))</span><br><span class="line">     <span class="keyword">goto</span> err;</span><br><span class="line">   flush_logs= <span class="number">0</span>; <span class="comment">/* not anymore; that would not be sensible */</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>这里主要是执行sql <code>flush logs</code>，用来刷新一下binlog，为了更好的区分开始dump的数据点和未来需要继续重放的增量位点。</p>
<h4 id="2-3-6-SHOW-MASTER-STATUS"><a href="#2-3-6-SHOW-MASTER-STATUS" class="headerlink" title="2.3.6. SHOW MASTER STATUS"></a>2.3.6. SHOW MASTER STATUS</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (opt_master_data &amp;&amp; do_show_master_status(sock))</span><br><span class="line">   goto err;</span><br></pre></td></tr></table></figure>

<p>在上一步中，我们给了server全局锁并且拿到了一致性事务视图，为了降低难度更是刷新了binlog文件，就可以放心的获取当前位点状态了。直接执行 <code>SHOW MASTER STATUS</code> 获取位点。</p>
<h4 id="2-3-7-UNLOCK-TABLES"><a href="#2-3-7-UNLOCK-TABLES" class="headerlink" title="2.3.7. UNLOCK TABLES"></a>2.3.7. UNLOCK TABLES</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (opt_single_transaction &amp;&amp; do_unlock_tables(sock)) <span class="comment">/* unlock but no commit! */</span></span><br><span class="line">   <span class="keyword">goto</span> err;</span><br></pre></td></tr></table></figure>

<p>拿到了位点之后，需要将锁释放掉，让 Server 恢复读写，也因此，需要执行 SQL <code>UNLOCCK TABLES</code>。而接下来，我们就是要分情况去 dump 数据了。</p>
<h4 id="2-3-8-DUMP"><a href="#2-3-8-DUMP" class="headerlink" title="2.3.8. DUMP"></a>2.3.8. DUMP</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (opt_alldbs)</span><br><span class="line">  dump_all_databases();</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (argc &gt; <span class="number">1</span> &amp;&amp; !opt_databases)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* Only one database and selected table(s) */</span></span><br><span class="line">  dump_selected_tables(*argv, (argv + <span class="number">1</span>), (argc - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* One or more databases, all tables */</span></span><br><span class="line">  dump_databases(argv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据命令行传入的参数不同，决定是 dump 全量 DB 还是某个 DB 下的一些表还是某些 DB 下的所有表。</p>
<p>而关键做事情的函数是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static int dump_all_tables_in_db(char *database)</span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  if (lock_tables)</span><br><span class="line">  &#123;</span><br><span class="line">    DYNAMIC_STRING query;</span><br><span class="line">    init_dynamic_string(&amp;query, &quot;LOCK TABLES &quot;, 256, 1024);</span><br><span class="line">    for (numrows&#x3D; 0 ; (table&#x3D; getTableName(1)) ; numrows++)</span><br><span class="line">    &#123;</span><br><span class="line">      dynstr_append(&amp;query, quote_name(table, table_buff, 1));</span><br><span class="line">      dynstr_append(&amp;query, &quot; READ &#x2F;*!32311 LOCAL *&#x2F;,&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    if (numrows &amp;&amp; mysql_real_query(sock, query.str, query.length-1))</span><br><span class="line">      DBerror(sock, &quot;when using LOCK TABLES&quot;);</span><br><span class="line">            &#x2F;* We shall continue here, if --force was given *&#x2F;</span><br><span class="line">    dynstr_free(&amp;query);</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  while ((table&#x3D; getTableName(0)))</span><br><span class="line">  &#123;</span><br><span class="line">    char *end&#x3D; strmov(afterdot, table);</span><br><span class="line">    if (include_table(hash_key, end - hash_key))</span><br><span class="line">    &#123;</span><br><span class="line">      numrows &#x3D; getTableStructure(table, database);</span><br><span class="line">      if (!dFlag &amp;&amp; numrows &gt; 0)</span><br><span class="line">	dumpTable(numrows,table);</span><br><span class="line">      my_free(order_by, MYF(MY_ALLOW_ZERO_PTR));</span><br><span class="line">      order_by&#x3D; 0;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  if (lock_tables)</span><br><span class="line">    mysql_query_with_error_report(sock, 0, &quot;UNLOCK TABLES&quot;);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int dump_selected_tables(char *db, char **table_names, int tables)</span><br><span class="line">&#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p><code>dump_all_tables_in_db</code> 和 <code>dump_selected_tables</code> 实现方式大同小异，不过 dump_all_tables_in_db 由于不需要手动指定 DB ，所以，只需要获取当前一致性事务中，存在的 tables 即可，可以从系统表中或者直接 show tables 获取，而 dump_selected_tables 由于有一个手动输入过程，所以，还要去校验一下输入的 tables 是否在 Server 中存在。</p>
<p>他们相同的地方就是，都对某个库下的 tables 加锁，然后获取完整个库下面的 Tables 数据后，再执行<code>UNLOCK TABLES</code>。</p>
<p>由于 MySQL 的 DDL 并不支持事务，所以，很不幸，如果你在 dump 过程中做了 DDL，可能会出现一些问题。而在目前的 8.0 版本中，依然没有对 DDL 支持事务。</p>
<h4 id="2-3-9-COMMIT"><a href="#2-3-9-COMMIT" class="headerlink" title="2.3.9. COMMIT"></a>2.3.9. COMMIT</h4><p>找了通篇，都不会找到的。因为，仅仅是执行了 DQL ，所以在链接断开时，自动去做 commit 是没有问题的。</p>
<h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><p>当有了隔离级别以后，可以比较准确的获取数据信息，轻松拿到待同步的增量位点，而 binlog 也是可以反向解析成 SQL 的。因此，虽然 mysqldump 已经老的提不动刀，无法继续冲杀在一线生产环境。但是，他依然为很多异构数据库提供了同步 MySQL 数据的思路和方法。</p>
<p>比如，16年开源的迅速在中国成为时下最火爆的 AP 数据库 <a href="https://clickhouse.yandex/docs/" target="_blank" rel="noopener">ClickHouse</a>，他实现了 <a href="https://bohutang.me/3030/12/12/clickhouse-and-friends-mysql-replication-materializemysql/#7-%E7%9B%B8%E5%85%B3%E5%8D%9A%E6%96%87" target="_blank" rel="noopener">MaterializeMySQL 引擎</a>，可以实现对 MySQL 5.7 和 MySQL 8.0 的全量 + 增量同步。目前这个功能的使用者和体验者还不是很多，但是预估在不久的未来，会成为一个企业级可用的功能。</p>
]]></content>
      <categories>
        <category>DataBase</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>天啊我的 MySQL 出 bug 了</title>
    <url>/2020/06/13/%E5%A4%A9%E5%95%8A%E6%88%91%E7%9A%84-MySQL-%E5%87%BA-bug-%E4%BA%86/</url>
    <content><![CDATA[<p>有这么一天，我们吃着火锅，唱着歌，突然就被手机铃声给劫了。一接电话</p>
<p>问曰：咋回事捏？</p>
<p>骂曰：看看你这破数据库，error log 里面居然有 bug 信息。赶紧回来，不然别想混了！！！</p>
<p>得，骑上我心爱的小毛驴飞过去处理吧。</p>
<a id="more"></a>

<p>其实，数据库也是一种软件，而软件怎么会没有 bug 呢？曾记得小时候的武侠中都是这样的，独孤九剑，没有固定的招式，而想要学会太极拳就要忘记太极拳。</p>
<p>那么怎么让软件没有 bug 呢？或许就是消灭这个软件吧。那么什么样的软件 bug 少呢？或许就是使用者极少吧。</p>
<p>好了，言归正传，当我们真的遇到 MySQL 日志中打印了一堆 bug 信息该怎么解决呢？</p>
<h2 id="1-这是一段-bug"><a href="#1-这是一段-bug" class="headerlink" title="1. 这是一段 bug"></a>1. 这是一段 bug</h2><p>当我们看到 error log 中出现下面的描述，一般是使用方法错误，或者真的遇到了 bug。这个时候，只需要根据 stack 信息进行 trace，就能进一步定位问题。</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">03:51:06 UTC - mysqld got signal 11 ;</span><br><span class="line">This could be because you hit a bug. It is also possible that this binary</span><br><span class="line">or one of the libraries it was linked against is corrupt, improperly built,</span><br><span class="line">or misconfigured. This error can also be caused by malfunctioning hardware.</span><br><span class="line">We will try our best to scrape up some info that will hopefully help</span><br><span class="line">diagnose the problem, but since we have already crashed, </span><br><span class="line">something is definitely wrong and this may fail.</span><br><span class="line">Please help us make Percona Server better by reporting any</span><br><span class="line">bugs at https://bugs.percona.com/</span><br><span class="line"></span><br><span class="line">key_buffer_size=8388608</span><br><span class="line">read_buffer_size=131072</span><br><span class="line">max_used_connections=0</span><br><span class="line">max_threads=153</span><br><span class="line">thread_count=0</span><br><span class="line">connection_count=0</span><br><span class="line">It is possible that mysqld could use up to </span><br><span class="line">key_buffer_size + (read_buffer_size + sort_buffer_size)*max_threads = 69061 K  bytes of memory</span><br><span class="line">Hope that&#x27;s ok; if not, decrease some variables in the equation.</span><br><span class="line"></span><br><span class="line">Thread pointer: 0x0</span><br><span class="line">Attempting backtrace. You can use the following information to find out</span><br><span class="line">where mysqld died. If you see no messages after this, something went</span><br><span class="line">terribly wrong...</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>你看，MySQL 告诉你了，如果真的啥都没有，那么可就糟糕透了。万幸的是，我们继续往下看，能看到一些东西。</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">stack_bottom = 0 thread_stack 0x40000</span><br><span class="line">./bin/mysqld(my_print_stacktrace+0x3b)[0x8f7eab]</span><br><span class="line">./bin/mysqld(handle_fatal_signal+0x49a)[0x66d55a]</span><br><span class="line">/lib/x86_64-linux-gnu/libpthread.so.0(+0x11390)[0x7f6f44fc2390]</span><br><span class="line">./bin/mysqld(_ZN9MYSQL_LOG17generate_new_nameEPcPKc+0x9d)[0x657c4d]</span><br><span class="line">./bin/mysqld(_ZN9MYSQL_LOG26init_and_set_log_file_nameEPKcS1_13enum_log_type10cache_type+0x57)[0x657d07]</span><br><span class="line">./bin/mysqld(_ZN13MYSQL_BIN_LOG11open_binlogEPKcS1_10cache_typembbbbP28Format_description_log_event+0x7b)[0x89a22b]</span><br><span class="line">./bin/mysqld(_Z11mysqld_mainiPPc+0x1bab)[0x5acbfb]</span><br><span class="line">/lib/x86_64-linux-gnu/libc.so.6(__libc_start_main+0xf0)[0x7f6f44366830]</span><br><span class="line">./bin/mysqld(_start+0x29)[0x59e659]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>好家伙，虚惊一场啊。有了 bug 果还有 bug 因，接下来，我们只需要沿着脉络去探索就好了。或许问题不大。</p>
<h2 id="2-理清-bug-迎难而上吧"><a href="#2-理清-bug-迎难而上吧" class="headerlink" title="2. 理清 bug 迎难而上吧"></a>2. 理清 bug 迎难而上吧</h2><p>对于一些”高玩“们，看懂这段 bug info 并不是什么难事，而对于我们，难如登天啊有木有，一段段的内存地址，密密麻麻的英文描述。所以，这个时候，我们需要什么，需要工具！！</p>
<p>我相信如果你能看到这里，已经通过 <a href="/2020/06/13/%E7%A9%BA%E6%9C%89-MySQL-Server-%E5%A6%82%E4%BD%95%E6%88%90%E4%B8%BA%E9%AB%98%E7%8E%A9/" title="空有-MySQL-Server-如何成为高玩">空有-MySQL-Server-如何成为高玩</a> 将 debug 后的 mysqld 加入到了机器的 PATH 变量中。</p>
<p>我们继续以上面的 bug info 为例子，看看如何让他变成代码具体位置。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mysqld_path=$(<span class="built_in">which</span> mysqld)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> nm  -n <span class="variable">$mysqld_path</span> &gt; /tmp/mysqld.sym</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：编译的 debug 版本，可以将 <code>which mysqld</code> 替换为 <code>which mysqld-debug</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> resolve_stack_dump 位于 MySQL basedir/bin</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 我把上面的 bug info 存到了 /tmp/mysqld.stack 中</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> resolve_stack_dump -s /tmp/mysqld.sym -n /tmp/mysqld.stack</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>当解析完毕后，我们可以看到关键部分已经发生了变化，更具体的打印了函数名，而我们又怎能满足于函数名呢？不要求具体列位置，最起码给个行定位吧大哥。</p>
<p>不要着急，真相就在眼前。</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">03:51:06 UTC - mysqld got signal 11 ;</span><br><span class="line">This could be because you hit a bug. It is also possible that this binary...</span><br><span class="line">Thread pointer: 0x0</span><br><span class="line">Attempting backtrace. You can use the following information to find out</span><br><span class="line">where mysqld died. If you see no messages after this, something went</span><br><span class="line">terribly wrong...</span><br><span class="line">stack_bottom = 0 thread_stack 0x40000</span><br><span class="line">0x8f7eab my_print_stacktrace + 59</span><br><span class="line">0x66d55a handle_fatal_signal + 1178</span><br><span class="line">0x7f6f44fc2390 _end + 1136550664</span><br><span class="line">0x657c4d _ZN9MYSQL_LOG17generate_new_nameEPcPKc + 157</span><br><span class="line">0x657d07 _ZN9MYSQL_LOG26init_and_set_log_file_nameEPKcS1_13enum_log_type10cache_type + 87</span><br><span class="line">0x89a22b _ZN13MYSQL_BIN_LOG11open_binlogEPKcS1_10cache_typembbbbP28Format_description_log_event + 123</span><br><span class="line">0x5acbfb _Z11mysqld_mainiPPc + 7083</span><br><span class="line">0x7f6f44366830 _end + 1123592104</span><br><span class="line">0x59e659 _start + 41</span><br></pre></td></tr></table></figure>

<p>我们只需要稍稍改动上面的命令，就好了</p>
<blockquote>
<p>resolve_stack_dump -s /tmp/mysqld.sym -n /tmp/mysqld.stack | c++filt</p>
</blockquote>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">Thread pointer: 0x0</span><br><span class="line">Attempting backtrace. You can use the following information to find out</span><br><span class="line">where mysqld died. If you see no messages after this, something went</span><br><span class="line">terribly wrong...</span><br><span class="line">stack_bottom = 0 thread_stack 0x40000</span><br><span class="line">0x8f7eab my_print_stacktrace + 59</span><br><span class="line">0x66d55a handle_fatal_signal + 1178</span><br><span class="line">0x7f6f44fc2390 _end + 1136550664</span><br><span class="line">0x657c4d MYSQL_LOG::generate_new_name(char*, char const*) + 157</span><br><span class="line">0x657d07 MYSQL_LOG::init_and_set_log_file_name(char const*, char const*, enum_log_type, cache_type) + 87</span><br><span class="line">0x89a22b MYSQL_BIN_LOG::open_binlog(char const*, char const*, cache_type, unsigned long, bool, bool, bool, bool, Format_description_log_event*) + 123</span><br><span class="line">0x5acbfb mysqld_main(int, char**) + 7083</span><br><span class="line">0x7f6f44366830 _end + 1123592104</span><br><span class="line">0x59e659 _start + 41</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="3-怎么定位这个锤儿-bug-呦"><a href="#3-怎么定位这个锤儿-bug-呦" class="headerlink" title="3. 怎么定位这个锤儿 bug 呦"></a>3. 怎么定位这个锤儿 bug 呦</h2><p>从这个报错来看，在启动过程中，要打开 binlog 文件，而在打开文件过程中失败了。这种报错 99.9% 都是文件系统问题，而 99% 可能是文件系统磁盘空间满了，可以通过一些命令去排查：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> df -Pih</span></span><br><span class="line">文件系统       Inode 已用(I) 可用(I) 已用(I)% 挂载点</span><br><span class="line">udev            2.5M     582    2.5M       1% /dev</span><br><span class="line">tmpfs           2.5M    1.2K    2.5M       1% /run</span><br><span class="line">/dev/nvme0n1p2   15M    1.8M     14M      12% /</span><br><span class="line">...</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="4-最重要的事儿"><a href="#4-最重要的事儿" class="headerlink" title="4. 最重要的事儿"></a>4. 最重要的事儿</h2><p>想必大家都听说过南辕北辙的故事，大概就是要往一边去，然后，从相反的方向出发。而判断 bug 到底出在哪里更是如此，我们一定要选对路，一直走到头。</p>
<p>那么，无论你是否能够坚持，选对路很重要，毕竟，rootcause 可能就在路口等你。</p>
<p>对于这次 debug ，选对路就是选对 mysqld 版本。记得，一定要用报错的 mysqld 去分析问题。否则，就是南辕北辙。毕竟，谁能准确记得每个不同小版本之间，bug info 涉及的代码没有被人修改呢？</p>
]]></content>
      <categories>
        <category>DataBase</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>如何编译安装MySQL Server</title>
    <url>/2020/06/13/%E5%A6%82%E4%BD%95%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85MySQL-Server/</url>
    <content><![CDATA[<p>众所周知，<a href="https://www.mysql.com/">MySQL</a>依然是<a href="https://db-engines.com/en/ranking">最流行的开源数据库</a>没有之一。那么如何使用他，如何揭开他流行的奥秘呢？这一切的一切可能要从最基础的编译安装开始说起。</p>
<a id="more"></a>

<h2 id="1-编译-release-版本"><a href="#1-编译-release-版本" class="headerlink" title="1. 编译 release 版本"></a>1. 编译 release 版本</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> https://github.com/TCeason/tokudb.git mysql</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> mysql</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout releases-tags</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git submodule init</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git submodule update</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> mkdir build; <span class="built_in">cd</span> build</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cmake ..\</span></span><br><span class="line">  -DCMAKE_BUILD_TYPE=RelWithDebInfo\</span><br><span class="line">  -DBUILD_CONFIG=mysql_release\</span><br><span class="line">  -DFEATURE_SET=community\</span><br><span class="line">  -DWITH_EMBEDDED_SERVER=OFF\</span><br><span class="line">  -DTOKUDB_VERSION=7.5.6\</span><br><span class="line">  -DBUILD_TESTING=OFF\</span><br><span class="line">  -DWITHOUT_ROCKSDB=ON\</span><br><span class="line">  -DWITH_BOOST=../extra/boost/boost_1_59_0.tar.gz\</span><br><span class="line">  -DCOMPILATION_COMMENT=&quot;Study MySQL build $(date +%Y%m%d.%H%M%S.$(git rev-parse --short HEAD))&quot;\</span><br><span class="line">  -DCMAKE_INSTALL_PREFIX=  # MySQL basedir 路径</span><br><span class="line"><span class="meta">  #</span><span class="bash"> cmake 的时候，如果没有依赖项需要自行安装</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make -jn <span class="comment"># n的数量取决于 CPU Core 数，如果 make -j报错，尝试 make</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make install</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="2-编译-Debug-版本"><a href="#2-编译-Debug-版本" class="headerlink" title="2. 编译 Debug 版本"></a>2. 编译 Debug 版本</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> https://github.com/TCeason/tokudb.git mysql</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> mysql</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout releases-tags</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git submodule init</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git submodule update</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> mkdir build</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> build</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cmake ..\</span></span><br><span class="line">  -DCMAKE_BUILD_TYPE=Debug\</span><br><span class="line">  -DBUILD_CONFIG=mysql_release\</span><br><span class="line">  -DFEATURE_SET=community\</span><br><span class="line">  -DWITH_EMBEDDED_SERVER=OFF\</span><br><span class="line">  -DTOKUDB_VERSION=7.5.6\</span><br><span class="line">  -DBUILD_TESTING=OFF\</span><br><span class="line">  -DWITHOUT_ROCKSDB=ON\</span><br><span class="line">  -DWITH_BOOST=../extra/boost/boost_1_59_0.tar.gz\</span><br><span class="line">  -DCMAKE_INSTALL_PREFIX=  # MySQL basedir 路径</span><br><span class="line"><span class="meta">$</span><span class="bash"> make -jn <span class="comment"># n的数量取决于 CPU Core 数，如果 make -j报错，尝试 make</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make install</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>随着 MySQL 版本的不断更新，编译参数可能会发生变动，当出现一些问题时，还是需要参考下面的信息：</p>
<p><a href="https://dev.mysql.com/doc/refman/8.0/en/installing.html">https://dev.mysql.com/doc/refman/8.0/en/installing.html</a></p>
<p><a href="https://github.com/TCeason/tokudb">https://github.com/TCeason/tokudb</a></p>
<p><a href="https://github.com/XeLabs/tokudb/wiki">https://github.com/XeLabs/tokudb/wiki</a></p>
<p>如果有对于 Percona Server Backport 感兴趣的朋友，欢迎讨论。</p>
]]></content>
      <categories>
        <category>DataBase</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>空有 MySQL Server 如何成为高玩</title>
    <url>/2020/06/13/%E7%A9%BA%E6%9C%89-MySQL-Server-%E5%A6%82%E4%BD%95%E6%88%90%E4%B8%BA%E9%AB%98%E7%8E%A9/</url>
    <content><![CDATA[<p>通过 <a href="/2020/06/13/%E5%A6%82%E4%BD%95%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85MySQL-Server/" title="如何编译安装MySQL-Server">如何编译安装MySQL-Server</a>，我们终于了解了如何进行对 MySQL Server 进行编译安装。那么如何进一步了解成为真正的 MySQL ”高玩“ 呢？</p>
<a id="more"></a>

<p>这个问题，我相信，网络上有很多答案。但是，我认为，真相只有一个～，自己动手编译 debug 版本，然后，进行 gdb 来判断。你可能觉得，这样的方式过于”老土“，而且非常不友好，毕竟还要掌握gdb，多一种学习路径，对于初入者的难度无疑是几何级增长。</p>
<p>没关系，MySQL 提供了一个贴心的功能，可以让我们通过类似阅读日志的方式读一下 Server 和 Client 到底在做什么。</p>
<blockquote>
<p>注意： </p>
<ol>
<li><p>接下来的方法一定要在编译 <code>debug</code> 版本后在进行使用哦。<br>接下来的方法一定要在编译 <code>debug</code> 版本后在进行使用哦。<br>接下来的方法一定要在编译 <code>debug</code> 版本后在进行使用哦。<br>重要的事情说三遍，嘻嘻。 </p>
</li>
<li><p>需要自行将编译好的 MySQL binary 包加入到使用主机的<code>PATH</code>变量中。</p>
</li>
</ol>
</blockquote>
<h2 id="1-debug-mysqld"><a href="#1-debug-mysqld" class="headerlink" title="1. debug: mysqld"></a>1. debug: mysqld</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Session1: </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> mysqld-debug --initialize-insecure --debug=d,info,error,query,general,<span class="built_in">where</span>:O,/tmp/mysqld.trace</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Session2:</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> tail -f /tmp/mysqld.trace</span></span><br></pre></td></tr></table></figure>

<p><strong>Note:</strong> 不做任何 defaults-file 设置的话，datadir 位于 $basedir/data</p>
<h2 id="2-debug-mysql-client"><a href="#2-debug-mysql-client" class="headerlink" title="2. debug: mysql client"></a>2. debug: mysql client</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Session1:</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> mysql -uusername --debug=d:t:O,/tmp/client.trace</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Session2:</span></span><br><span class="line"><span class="meta">$</span><span class="bash">tail -f /tmp/client.trace</span></span><br></pre></td></tr></table></figure>

<p>加油吧少年，欢乐时光开始啦。（手动滑稽）</p>
<p>如果还是有些许不明白可以参考官方链接，不过个人建议还是先折磨一下自己哦</p>
<p><a href="https://dev.mysql.com/doc/refman/8.0/en/porting.html">https://dev.mysql.com/doc/refman/8.0/en/porting.html</a></p>
]]></content>
      <categories>
        <category>DataBase</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>ClickHouse OOM 分析</title>
    <url>/2020/11/30/ClickHouse-OOM-%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>Out Of Memory （OOM）到目前为止已经出现了 40 年。大概就是当某个应用想要使用的内存超过了现有可用的内存总和，本文将不会具体进行赘述。为了防止发生OOM ，采取了各种各样的方式，最常见的就是，当申请内存时，发现无法申请所需要的内存，系统主动 <code>kill</code> 当前内存占用最大的应用。</p>
<p>这样带来的好处是，当前应用可以正常使用了。但是，缺点也是显而易见的：会让当前最大内存占用的应用无法正常运行。</p>
<p>在数据库中，这尤为常见。比如，在一台数据库服务器中运行了  MySQL Server ，同时要对这个数据库进行备份，而执行 mysqldump 或者 xtrabackup 或者 mydumper 等等备份命令时，由于机器内存不足以运行备份命令，而 <code>kill</code> 掉了内存占用最大的 <code>MySQL Server</code>。着带来的后果就很直接了，业务读写失败。</p>
<p>同样的，当下的 OLAP 骄子 <code>ClickHouse</code> 也是存在这种问题，那么他的 OOM 一般是如何引起的呢，又要如何避免呢？</p>
<a id="more"></a>

<h2 id="2-发生-OOM-的原因"><a href="#2-发生-OOM-的原因" class="headerlink" title="2. 发生 OOM 的原因"></a>2. 发生 OOM 的原因</h2><p>OOM 是什么我们已经知道了，那么，ClickHouse OOM 的原因其实应该主要分为</p>
<ul>
<li><p>查询导致 OOM </p>
</li>
<li><p>写入导致 OOM </p>
</li>
</ul>
<p>查询导致 OOM 比较好理解，就是，当某个 query 要读取的数据量过大了，内存不够用。</p>
<p>写入会导致 OOM 可能大家不是很理解，有人如果认为 insert into select 是属于写入导致 OOM ，这应该不算全对，毕竟还进行了查询。所以，接下来，我们仔细区分一下这两类原因。</p>
<h3 id="2-1-查询导致OOM"><a href="#2-1-查询导致OOM" class="headerlink" title="2.1. 查询导致OOM"></a>2.1. 查询导致OOM</h3><p>比如某个大数据量的表做聚合排序（ <code>GROUP BY</code> 和 <code>ORDER BY</code>）操作，导致需要将大量的数据读取到内存中，然后按照 SQL 要求进行分组和排序。数据对内存的消耗基本是 数据:内存&gt; 1:1 的。也就是，如果有 1GB 数据需要做聚合排序操作，那么他需要的内存是要超过 1GB 的。数据量越大，所需内存会更加巨大。常见的机器是无法满足这种需求的。</p>
<h3 id="2-2-写入导致OOM"><a href="#2-2-写入导致OOM" class="headerlink" title="2.2. 写入导致OOM"></a>2.2. 写入导致OOM</h3><p>对于大多数小内存的数据库服务器来说，如果一次写入的batch过大都有可能会引起OOM。但是，对于 ClickHouse 来说，可能却不是这样。并发线程数目20 ，每个线程只写入一行，每行写入的列只有 15 个。都有可能引发 OOM 。</p>
<p>可能看到这里会觉得 ClickHouse 一定设计的不合理，要不然为什么如此小的数据写入都会引发 OOM 呢？</p>
<p>如果会有这样的问题，说明不是很了解 ClickHouse 。ClickHouse 支持多种表引擎。其中有一个 MergeTree 族群表引擎，MergeTree 在 ClickHouse 的地位基本等同于 Innodb 在 MySQL 的地位。MergeTree 引擎是基于 LSM 算法实现的。每次写入就会生成一个小文件，然后 ClickHouse Server 再去合并每个小文件到数据文件中。关于 MergeTree 原理将会在后面的文章中进行详细介绍。</p>
<p>理解了MergeTree的 merge 工作后，就比较清晰了。当多个线程每次只写入一行数据时， insert query 的每个列会生成两个文件。因此，按照上面的写入方式，计算出消耗的内存为：</p>
<blockquote>
<p>2MB * 15 * 20 = 600 MB</p>
</blockquote>
<p>600MB 可能不大，但是，换算一下百分比，如果机器内存是 8GB ，8GB 的 10% 内存也只有 800MB 左右呀。而一个数据库机器，一般负载下内存占用达到机器的 70% 左右。如果突然来这么一次20行数据的写入，内存就会飙升 10% ，我想这会是很令人疑惑的一件事。而且，如果有人在 AP 中一次写入只包含一行数据，那他可能确实没有理解 AP 数据库的精髓所在。</p>
<h2 id="3-如何避免-OOM"><a href="#3-如何避免-OOM" class="headerlink" title="3. 如何避免 OOM"></a>3. 如何避免 OOM</h2><p>OOM 的原因我们简单分析过了，主要是查询和不正当写入导致的。因此，避免 OOM 也就变得简单起来。</p>
<h3 id="3-1-避免查询时-OOM"><a href="#3-1-避免查询时-OOM" class="headerlink" title="3.1. 避免查询时 OOM"></a>3.1. 避免查询时 OOM</h3><p>对于如何避免查询时发生 OOM ，数据库常见的做法就是外排到磁盘。比如，众所周知的，MySQL 查询慢了，就去 explain，看到结果有臭名昭著的 <code>Using filesort</code> 而刚好要排序的数据量大于session的 sort_buffer 时，就会自动使用磁盘排序了。</p>
<p>而 ClickHouse 的做法也是比较类似。同样也有 setting 进行控制：</p>
<blockquote>
<p><a href="https://clickhouse.tech/docs/en/sql-reference/statements/select/group-by/#select-group-by-in-external-memory" target="_blank" rel="noopener">max_bytes_before_external_group_by</a>: The max_bytes_before_external_group_by setting determines the threshold RAM consumption for dumping GROUP BY temporary data to the file system. If set to 0 (the default), it is disabled.</p>
<p><a href="https://clickhouse.tech/docs/en/sql-reference/statements/select/order-by/#implementation-details" target="_blank" rel="noopener">max_bytes_before_external_sort</a>: If there is not enough RAM, it is possible to perform sorting in external memory (creating temporary files on a disk). Use the setting max_bytes_before_external_sort for this purpose. If it is set to 0 (the default), external sorting is disabled. If it is enabled, when the volume of data to sort reaches the specified number of bytes, the collected data is sorted and dumped into a temporary file. After all data is read, all the sorted files are merged and the results are output. Files are written to the /var/lib/clickhouse/tmp/ directory in the config (by default, but you can use the tmp_path parameter to change this setting).</p>
</blockquote>
<h3 id="3-2-避免写入时-OOM"><a href="#3-2-避免写入时-OOM" class="headerlink" title="3.2. 避免写入时 OOM"></a>3.2. 避免写入时 OOM</h3><p>而避免写入时OOM ，就不应该在强求 ClickHouse 来实现了。而是需要对业务做一些修改，比如:</p>
<ul>
<li><p>降低并发线程数；</p>
</li>
<li><p>每个 insert 中采用更大的 batch 。</p>
</li>
</ul>
<p>毕竟，我们同样不能苛责向小型 MySQL Server 服务器 一次写入 10万行数据时性能不佳呀。</p>
]]></content>
      <categories>
        <category>DataBase</category>
      </categories>
      <tags>
        <tag>ClickHouse</tag>
      </tags>
  </entry>
  <entry>
    <title>什么是 HashTable</title>
    <url>/2021/06/21/%E4%BB%80%E4%B9%88%E6%98%AF-HashTable/</url>
    <content><![CDATA[<p>HashTable 是一种存储 key-value pairs（键值对）的数据结构。</p>
<p>Key 是被发送到一个用来对其实行运算的 hash 函数。</p>
<p>这个过程称为 Hashing（散列）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hash 函数运算后的结果（通常被称为 &#96;hash 值&#96; 或者 hash）是 key-value pair 在 HashTable 中的索引。</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="组成部分"><a href="#组成部分" class="headerlink" title="组成部分"></a>组成部分</h2><p>基本的 HashTable 包括两个部分：</p>
<h3 id="Hash-Function"><a href="#Hash-Function" class="headerlink" title="Hash Function"></a>Hash Function</h3><p>正如我们上面提到的，hash 函数决定了我们 key-value pair 的索引。选择一个高效的 hash 函数是创建一个好的 HashTable 至关重要的部分。你应该始终确保他是一个单向函数（one-way function）。<br>即，无法从哈希中检索密钥。</p>
<p>好的的 hash 函数的另一个特性是：对于不同的 key 可以产生不同的 hash。</p>
<h3 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h3><p>Array 包含 HashTable 中所有 key-value 条目。数组的大小应该根据期望的数据量设置。</p>
<h2 id="Collisions-in-hash-tables-amp-resolutions"><a href="#Collisions-in-hash-tables-amp-resolutions" class="headerlink" title="Collisions in hash tables &amp; resolutions"></a>Collisions in hash tables &amp; resolutions</h2><p>当两个或者多个 key map（映射）到相同的 index（索引）会发生 collisions（<code>冲突</code>）。有几种处理 index 冲突的方法：</p>
<h3 id="Liner-probing"><a href="#Liner-probing" class="headerlink" title="Liner probing"></a>Liner probing</h3><p>如果一对 key-value 被分配到一个已经被占用的 slot（插槽），会线性的在当前 HashTable 搜索下一个空闲的插槽。</p>
<h3 id="Chaining"><a href="#Chaining" class="headerlink" title="Chaining"></a>Chaining</h3><p>HashTable 将会是一个链表数组。map 到同一 index 的所有 key 都将存储为该索引处的链表节点。</p>
<p>优势：</p>
<ul>
<li><p>通过 chaining，在哈希表中的插入总是在 O(1) 中发生，因为链表允许在恒定时间内插入。</p>
</li>
<li><p>理论上，只要有足够的空间，链式哈希表就可以无限增长。</p>
</li>
<li><p>使用 chaining 的哈希表永远不需要调整大小。</p>
</li>
</ul>
<h3 id="Resizing-the-HashTable"><a href="#Resizing-the-HashTable" class="headerlink" title="Resizing the HashTable"></a>Resizing the HashTable</h3><p>可以增加 HashTable 的大小，以便将 Hash 条目分割的更远。Threshold value（临界点）表示在调整大小之前需要占用的 HashTable 的百分比。HashTable threshold value 为 0.6 表示当 HashTable 空间使用率为 60 % 时进行一次扩容。按照惯例，HashTable 的大小扩容至二倍。这是内存密集型的。</p>
<h2 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h2><p>基于 chaining 实现。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HashTable</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; * table;</span><br><span class="line">    <span class="keyword">int</span> total_elements;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getHash</span><span class="params">(<span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key % total_elements;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    HashTable(<span class="keyword">int</span> n)</span><br><span class="line">    &#123;</span><br><span class="line">        total_elements = n;</span><br><span class="line">        table = <span class="keyword">new</span> <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;[total_elements];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insertElement</span><span class="params">(<span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        table[getHash(key)].push_back(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeElement</span><span class="params">(<span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = getHash(key);</span><br><span class="line">        <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator i;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = table[x].begin(); i != table[x].end(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (*i == key)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i != table[x].end())</span><br><span class="line">            table[x].erase(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printAll</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// Traverse each index.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; total_elements; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"Index "</span> &lt;&lt; i &lt;&lt; <span class="string">": "</span>;</span><br><span class="line">            <span class="comment">// Traverse the list at current index.</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j : table[i])</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; j &lt;&lt; <span class="string">"=&gt;"</span>;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">HashTable <span class="title">ht</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> arr[] = &#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">        ht.insertElement(arr[i]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"=== Hash Table ==="</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    ht.printAll();</span><br><span class="line"></span><br><span class="line">    ht.removeElement(<span class="number">4</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">"=== After delete element 4 ==="</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    ht.printAll();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Transate to <a href="https://www.educative.io/edpresso/how-to-implement-a-hash-table-in-cpp" target="_blank" rel="noopener">https://www.educative.io/edpresso/how-to-implement-a-hash-table-in-cpp</a></p>
]]></content>
      <categories>
        <category>DataStructures</category>
      </categories>
      <tags>
        <tag>HashTable</tag>
      </tags>
  </entry>
  <entry>
    <title>什么是heap</title>
    <url>/2021/06/30/%E4%BB%80%E4%B9%88%E6%98%AFheap/</url>
    <content><![CDATA[<p>心情不佳，我们来写个堆吧。</p>
<h2 id="堆的定义"><a href="#堆的定义" class="headerlink" title="堆的定义"></a>堆的定义</h2><p>堆我脑子里第一个浮现的是金字塔的外形。但是，抽象一下，更像是一棵树。</p>
<p>而在很多算法题中，有些 Top K 问题，在关键字和提示中，也经常出现 <code>堆</code> 这个字眼。</p>
<p>因此，简单来说，可以认为堆满足一些性质：</p>
<ul>
<li><p>堆中某个节点的值总是不大于或不小于父节点（因此有了最大堆和最小堆的说法，父最大为最大堆，父最小为最小堆）</p>
</li>
<li><p>堆是一个完全二叉树</p>
</li>
</ul>
<a id="more"></a>

<h2 id="支持函数"><a href="#支持函数" class="headerlink" title="支持函数"></a>支持函数</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 堆内元素个数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取父节点的值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写入一个值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将父节点值弹出</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>话不多说，我们直接开撕。</p>
<ul>
<li><p>heap.h</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> UNTITLED_HEAP_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UNTITLED_HEAP_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">heap</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    heap()</span><br><span class="line">    &#123;</span><br><span class="line">        _heap.push_back(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _heap.size() - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size() == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(T val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _heap.push_back(val);</span><br><span class="line">        <span class="keyword">auto</span> index = size();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (index / <span class="number">2</span> &gt; <span class="number">0</span> &amp;&amp; _heap[index] &gt; _heap[index / <span class="number">2</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            swap(_heap[index], _heap[index / <span class="number">2</span>]);</span><br><span class="line">            index /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (empty())</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> heap_size = size();</span><br><span class="line">        swap(_heap[<span class="number">1</span>], _heap[heap_size]);</span><br><span class="line">        _heap.pop_back();</span><br><span class="line">        heap_size--;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> maxI = index;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="number">2</span> * index &lt;= heap_size &amp;&amp; _heap[index] &lt; _heap[<span class="number">2</span> * index])</span><br><span class="line">                maxI = <span class="number">2</span> * index;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">2</span> * index + <span class="number">1</span> &lt; heap_size &amp;&amp; _heap[maxI] &lt; _heap[<span class="number">2</span> * index])</span><br><span class="line">                maxI = <span class="number">2</span> * index + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (maxI == index)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            swap(_heap[index], _heap[maxI]);</span><br><span class="line">            index = maxI;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; _heap.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; _heap[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;T&gt; _heap;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//UNTITLED_HEAP_H</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>main.cpp</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"heap.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    heap&lt;<span class="keyword">int</span>&gt; bigheap;</span><br><span class="line">    bigheap.push(<span class="number">4</span>);</span><br><span class="line">    bigheap.push(<span class="number">3</span>);</span><br><span class="line">    bigheap.push(<span class="number">2</span>);</span><br><span class="line">    bigheap.push(<span class="number">1</span>);</span><br><span class="line">    bigheap.push(<span class="number">5</span>);</span><br><span class="line">    bigheap.print();</span><br><span class="line">    bigheap.pop();</span><br><span class="line">    bigheap.print();</span><br><span class="line">    bigheap.pop();</span><br><span class="line">    bigheap.print();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>CMakeLists.txt</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 3.19)</span><br><span class="line">project(untitled)</span><br><span class="line"></span><br><span class="line">set(CMAKE_CXX_STANDARD 14)</span><br><span class="line"></span><br><span class="line">add_executable(untitled main.cpp)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="4-运行"><a href="#4-运行" class="headerlink" title="4. 运行"></a>4. 运行</h2><ul>
<li>编译</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cmake -DCMAKE_BUILD_TYPE=Debug -G <span class="string">"CodeBlocks - Unix Makefiles"</span> ./</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cmake --build ./ --target untitled</span></span><br></pre></td></tr></table></figure>

<ul>
<li>运行</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./untitled</span></span><br><span class="line">5 4 2 1 3 </span><br><span class="line">4 3 2 1 </span><br><span class="line">3 1 2</span><br></pre></td></tr></table></figure>

<h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><p>我们这里实现了一个大顶堆。聪明的你一定知道了小顶堆应该如何实现啦。</p>
<p>那么这里提出一个小问题，快排和堆都可以作为排序算法，</p>
<p>那么为什么我们在实际工程项目中快排的应用更加广泛呢？（或许可以从运行结果中发现端倪哦）</p>
]]></content>
      <categories>
        <category>DataStructures</category>
      </categories>
      <tags>
        <tag>Heap</tag>
      </tags>
  </entry>
  <entry>
    <title>更方便的使用git</title>
    <url>/2021/08/21/%E6%9B%B4%E6%96%B9%E4%BE%BF%E7%9A%84%E4%BD%BF%E7%94%A8git/</url>
    <content><![CDATA[<p>在我们日常学习和工作中， <a href="https://git-scm.com/" target="_blank" rel="noopener">git</a> 已经逐渐的和程序员绑定到了一起。</p>
<p>关于 git ，大家是这样去定义的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Git is a free and open source distributed version control system designed to handle everything from small to very large projects with speed and efficiency.</span><br><span class="line"></span><br><span class="line">Git is easy to learn and has a tiny footprint with lightning fast performance. It outclasses SCM tools like Subversion, CVS, Perforce, and ClearCase with features like cheap local branching, convenient staging areas, and multiple workflows.</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="1-简单的使用方法"><a href="#1-简单的使用方法" class="headerlink" title="1. 简单的使用方法"></a>1. 简单的使用方法</h2><p>目前来看，一套命令就可以完成一次 pr （代码的提交）。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> git add .</span><br><span class="line"><span class="variable">$</span> git commit <span class="literal">-m</span> <span class="string">'init commit'</span></span><br><span class="line"><span class="variable">$</span> git push</span><br></pre></td></tr></table></figure>

<p>而更简单的一行命令就可以看到一个文件的所有提交日志，我们以 ClickHouse 任意一个文件为例：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">➜  ~/database/source<span class="literal">-code</span>/ClickHouse👆 git:(<span class="number">21.1</span>.<span class="number">3.32</span>) ⚡ git log src/Core/Settings.h</span><br><span class="line"></span><br><span class="line">commit eaef015c6b3c3f86c43b98ba6fcc305779bac90c</span><br><span class="line">Author: robot<span class="literal">-clickhouse</span> &lt;robot<span class="literal">-clickhouse</span>@yandex<span class="literal">-team</span>.ru&gt;</span><br><span class="line">Date:   Thu Jan <span class="number">14</span> <span class="number">11</span>:<span class="number">53</span>:<span class="number">35</span> <span class="number">2021</span> +<span class="number">0300</span></span><br><span class="line"></span><br><span class="line">    Backport <span class="comment">#18981 to 21.1: Disable optimize out of any</span></span><br><span class="line"></span><br><span class="line">commit <span class="number">7</span>e9120b34fbf357c578c8035e2abeab2ec5c9d94</span><br><span class="line">Merge: aa8d4eec69 <span class="number">8387</span>ac86ef</span><br><span class="line">Author: Alexey Milovidov &lt;milovidov@yandex<span class="literal">-team</span>.ru&gt;</span><br><span class="line">Date:   Sun Jan <span class="number">10</span> <span class="number">04</span>:<span class="number">04</span>:<span class="number">47</span> <span class="number">2021</span> +<span class="number">0300</span></span><br><span class="line"></span><br><span class="line">    Merge branch <span class="string">'master'</span> into chenziliang/feature/wildcard<span class="literal">-dynamic</span><span class="literal">-columns</span></span><br></pre></td></tr></table></figure>

<h2 id="2-要优雅"><a href="#2-要优雅" class="headerlink" title="2. 要优雅"></a>2. 要优雅</h2><p>或许平时觉得这些就足够应付工作了。但是，做事要优雅，我们希望一眼就能看穿 “前世今生”。</p>
<p>因此单独介绍两个小命令：</p>
<blockquote>
<p>git log –graph<br>git blame -L</p>
</blockquote>
<h3 id="2-1-git-log-–graph"><a href="#2-1-git-log-–graph" class="headerlink" title="2.1. git log –graph"></a>2.1. git log –graph</h3><p>我们还是以上面的 <code>Settings.h</code> 为例子，当单纯的看 git log 时，确实可以看到每一次提交，但是，如何找到每个提交的关系呢？是在哪个分支之下呢？</p>
<p>在使用命令之前，请让我们先了解到底它在做什么</p>
<blockquote>
<p><a href="https://git-scm.com/docs/git-log#Documentation/git-log.txt---graph" target="_blank" rel="noopener">–graph</a><br>Draw a text-based graphical representation of the commit history on the left hand side of the output. This may cause extra lines to be printed in between commits, in order for the graph history to be drawn properly. Cannot be combined with –no-walk.</p>
<p>This enables parent rewriting, see History Simplification above.</p>
</blockquote>
<p>简单来说，会生成一个点线图。好了，话不多说，看结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">➜  ~&#x2F;database&#x2F;source-code&#x2F;ClickHouse👆 git:(21.1.3.32) ⚡ git log --graph  src&#x2F;Core&#x2F;Settings.h</span><br><span class="line">* commit eaef015c6b3c3f86c43b98ba6fcc305779bac90c</span><br><span class="line">| Author: robot-clickhouse &lt;robot-clickhouse@yandex-team.ru&gt;</span><br><span class="line">| Date:   Thu Jan 14 11:53:35 2021 +0300</span><br><span class="line">| </span><br><span class="line">|     Backport #18981 to 21.1: Disable optimize out of any</span><br><span class="line">|   </span><br><span class="line">*   commit 7e9120b34fbf357c578c8035e2abeab2ec5c9d94</span><br><span class="line">|\  Merge: a7c350adda a3d19fa64d</span><br><span class="line">| | Author: Alexey Milovidov &lt;milovidov@yandex-team.ru&gt;</span><br><span class="line">| | Date:   Sun Jan 10 04:04:47 2021 +0300</span><br><span class="line">| | </span><br><span class="line">| |     Merge branch &#39;master&#39; into chenziliang&#x2F;feature&#x2F;wildcard-dynamic-columns</span><br><span class="line">| | </span><br><span class="line">| * commit a3d19fa64df8fc70fc6b6e5a0bc434721ae571e7</span><br><span class="line">| | Author: Amos Bird &lt;amosbird@gmail.com&gt;</span><br><span class="line">| | Date:   Fri Jan 8 12:28:09 2021 +0800</span><br><span class="line">| | </span><br><span class="line">| |     Correctly override default settings remotely</span><br><span class="line">| | </span><br><span class="line">| * commit 0260953a4785ac1daa6b3c17d6dc555ce59f8caf</span><br><span class="line">| | Author: Amos Bird &lt;amosbird@gmail.com&gt;</span><br><span class="line">| | Date:   Wed Jan 6 17:18:48 2021 +0800</span><br><span class="line">| | </span><br><span class="line">| |     better</span><br><span class="line">| | </span><br><span class="line">| * commit a157a5b3b3c4dd26d208cdb65c35bf579b4bcb52</span><br><span class="line">| | Author: Amos Bird &lt;amosbird@gmail.com&gt;</span><br><span class="line">| | Date:   Mon Jan 4 12:40:48 2021 +0800</span><br><span class="line">| | </span><br><span class="line">| |     add max_partitions_to_read setting</span><br><span class="line">| |</span><br></pre></td></tr></table></figure>

<p>很遗憾，这个图形非常让人眩晕，有时可能还会是这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">| * | | | | commit 85c1bc1253fef760b6f329381b694eed3e122e6d</span><br><span class="line">| |\| | | | Merge: 4bfcb2fc16 34e4ace029</span><br><span class="line">| | | | | | Author: Alexander Kuzmenkov &lt;akuzm@yandex-team.ru&gt;</span><br><span class="line">| | | | | | Date:   Mon Dec 21 10:46:21 2020 +0300</span><br><span class="line">| | | | | | </span><br><span class="line">| | | | | |     Merge remote-tracking branch &#39;origin&#x2F;master&#39; into tmp</span><br><span class="line">| | | | | |   </span><br><span class="line">| | * | | |   commit 34e4ace02948cd3d3bc5d43dba9a8e6c05249c85</span><br><span class="line">| | |\ \ \ \  Merge: e4433157e7 a0f7a12c4f</span><br><span class="line">| | | | | | | Author: alexey-milovidov &lt;milovidov@yandex-team.ru&gt;</span><br><span class="line">| | | | | | | Date:   Fri Dec 18 18:00:34 2020 +0300</span><br><span class="line">| | | | | | | </span><br><span class="line">| | | | | | |     Merge pull request #17525 from ClickHouse&#x2F;null-as-default-default</span><br><span class="line">| | | | | | |     </span><br><span class="line">| | | | | | |     Attempt to make NULL as default by default</span><br><span class="line">| | | | | | |   </span><br><span class="line">| | | * | | |   commit a0f7a12c4fa40bf04ef9ffedc0c8892fbf9d08a3</span><br><span class="line">| | | |\ \ \ \  Merge: 20e56da8ac cb91d64fe7</span><br><span class="line">| | | | | |_|&#x2F;  Author: Alexey Milovidov &lt;milovidov@yandex-team.ru&gt;</span><br><span class="line">| | | | |&#x2F;| |   Date:   Fri Dec 18 08:09:35 2020 +0300</span><br><span class="line">| | | | | | |   </span><br><span class="line">| | | | | | |       Merge branch &#39;master&#39; into null-as-default-default</span><br></pre></td></tr></table></figure>

<p>但是，当我们理解了每个符号的意思，也就可以比较清晰的理顺其中的关系。</p>
<blockquote>
<p><code>|</code> 表示分支向前<br><code>*</code> 表示一个 COMMIT ID，至于要管*在哪一条主线上<br><code>/</code> 表示从当前分支分叉，比如执行了 <code>git checkout -b 或者 git switch -c</code><br><code>\</code> 表示被合并</p>
</blockquote>
<p>因此</p>
<ul>
<li><code>|/</code> 表示从 <code>|</code> 所在分支切出来一个新的分支。</li>
<li><code>|\</code> 表示从当前的 <code>|</code> 分支，合并到并向的 <code>|</code> 分支。</li>
</ul>
<p>当我们独立操作两次之后，反而会对这些乱七八糟的毛线说一句 <code>LOVE YOU</code>。</p>
<h2 id="2-2-git-blame-L"><a href="#2-2-git-blame-L" class="headerlink" title="2.2. git blame -L"></a>2.2. git blame -L</h2><p>同理，操作之前，请先明白你在做什么。废话不多说，上文档。</p>
<blockquote>
<p><a href="https://git-scm.com/docs/git-blame" target="_blank" rel="noopener">git blame</a><br>git-blame - Show what revision and author last modified each line of a file</p>
</blockquote>
<p>blame 含有责备的意思，实际上，这个命令确实可以用来责任。因为他可以显示每一行最后一次的 commit 信息。</p>
<p>比如我们下面的例子所示，展示了 <code>Settings.h</code> 从第 20 -30 行，每一行最新的 commit id。里面包含了修改时间，作者以及修改记录摘要。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">➜  ~/database/source<span class="literal">-code</span>/ClickHouse👆 git:(<span class="number">21.1</span>.<span class="number">3.32</span>) ⚡ git blame <span class="literal">-L</span> <span class="number">20</span>,<span class="number">30</span> src/Core/Settings.h</span><br><span class="line"><span class="number">7</span>d9f3035995 dbms/include/DB/Interpreters/Settings.h (Alexey Milovidov     <span class="number">2012</span><span class="literal">-03</span><span class="literal">-05</span> <span class="number">00</span>:<span class="number">09</span>:<span class="number">41</span> +<span class="number">0000</span> <span class="number">20</span>) &#123;</span><br><span class="line">bd4d8a6766e dbms/src/Interpreters/Settings.h        (Vitaliy Lyudvichenko <span class="number">2018</span><span class="literal">-05</span><span class="literal">-17</span> <span class="number">19</span>:<span class="number">01</span>:<span class="number">41</span> +<span class="number">0300</span> <span class="number">21</span>) <span class="class"><span class="keyword">class</span> <span class="title">IColumn</span>;</span></span><br><span class="line"><span class="class">8277<span class="title">e9d8f12</span> <span class="title">dbms</span>/<span class="title">src</span>/<span class="title">Core</span>/<span class="title">Settings</span>.<span class="title">h</span>                (<span class="title">Vitaly</span> <span class="title">Baranov</span>       2019-04-19 02:29:32 +0300 22) </span></span><br><span class="line"><span class="class"><span class="title">f5adbceed2d</span> <span class="title">dbms</span>/<span class="title">src</span>/<span class="title">Interpreters</span>/<span class="title">Settings</span>.<span class="title">h</span>        (<span class="title">Alexey</span> <span class="title">Milovidov</span>     2018-06-03 23:39:06 +0300 23) </span></span><br><span class="line"><span class="class">56665<span class="title">a15f7f</span> <span class="title">src</span>/<span class="title">Core</span>/<span class="title">Settings</span>.<span class="title">h</span>                     (<span class="title">Vitaly</span> <span class="title">Baranov</span>       2020-07-20 12:57:17 +0300 24) /** <span class="title">List</span> <span class="title">of</span> <span class="title">settings</span>: <span class="title">type</span>, <span class="title">name</span>, <span class="title">default</span> <span class="title">value</span>, <span class="title">description</span>, <span class="title">flags</span></span></span><br><span class="line"><span class="class">56665<span class="title">a15f7f</span> <span class="title">src</span>/<span class="title">Core</span>/<span class="title">Settings</span>.<span class="title">h</span>                     (<span class="title">Vitaly</span> <span class="title">Baranov</span>       2020-07-20 12:57:17 +0300 25)   *</span></span><br><span class="line"><span class="class">56665<span class="title">a15f7f</span> <span class="title">src</span>/<span class="title">Core</span>/<span class="title">Settings</span>.<span class="title">h</span>                     (<span class="title">Vitaly</span> <span class="title">Baranov</span>       2020-07-20 12:57:17 +0300 26)   * <span class="title">This</span> <span class="title">looks</span> <span class="title">rather</span> <span class="title">unconvenient</span>. <span class="title">It</span> <span class="title">is</span> <span class="title">done</span> <span class="title">that</span> <span class="title">way</span> <span class="title">to</span> <span class="title">avoid</span> <span class="title">repeating</span> <span class="title">settings</span> <span class="title">in</span> <span class="title">different</span> <span class="title">places</span>.</span></span><br><span class="line"><span class="class">56665<span class="title">a15f7f</span> <span class="title">src</span>/<span class="title">Core</span>/<span class="title">Settings</span>.<span class="title">h</span>                     (<span class="title">Vitaly</span> <span class="title">Baranov</span>       2020-07-20 12:57:17 +0300 27)   * <span class="title">Note</span>: <span class="title">as</span> <span class="title">an</span> <span class="title">alternative</span>, <span class="title">we</span> <span class="title">could</span> <span class="title">implement</span> <span class="title">settings</span> <span class="title">to</span> <span class="title">be</span> <span class="title">completely</span> <span class="title">dynamic</span> <span class="title">in</span> <span class="title">form</span> <span class="title">of</span> <span class="title">map</span>: <span class="title">String</span> -&gt; <span class="title">Field</span>,</span></span><br><span class="line"><span class="class">56665<span class="title">a15f7f</span> <span class="title">src</span>/<span class="title">Core</span>/<span class="title">Settings</span>.<span class="title">h</span>                     (<span class="title">Vitaly</span> <span class="title">Baranov</span>       2020-07-20 12:57:17 +0300 28)   *  <span class="title">but</span> <span class="title">we</span> <span class="title">are</span> <span class="title">not</span> <span class="title">going</span> <span class="title">to</span> <span class="title">do</span> <span class="title">it</span>, <span class="title">because</span> <span class="title">settings</span> <span class="title">is</span> <span class="title">used</span> <span class="title">everywhere</span> <span class="title">as</span> <span class="title">static</span> <span class="title">struct</span> <span class="title">fields</span>.</span></span><br><span class="line"><span class="class">56665<span class="title">a15f7f</span> <span class="title">src</span>/<span class="title">Core</span>/<span class="title">Settings</span>.<span class="title">h</span>                     (<span class="title">Vitaly</span> <span class="title">Baranov</span>       2020-07-20 12:57:17 +0300 29)   *</span></span><br><span class="line"><span class="class">56665<span class="title">a15f7f</span> <span class="title">src</span>/<span class="title">Core</span>/<span class="title">Settings</span>.<span class="title">h</span>                     (<span class="title">Vitaly</span> <span class="title">Baranov</span>       2020-07-20 12:57:17 +0300 30)   * `<span class="title">flags</span>` <span class="title">can</span> <span class="title">be</span> <span class="title">either</span> 0 <span class="title">or</span> <span class="title">IMPORTANT</span>.</span></span><br></pre></td></tr></table></figure>

<h2 id="2-3-组合拳？？"><a href="#2-3-组合拳？？" class="headerlink" title="2.3. 组合拳？？"></a>2.3. 组合拳？？</h2><p>其实，无论是 git log –graph 还是 git blame -L 都是比较单独的手段。</p>
<p>但是当他们结合起来，是否可以发挥妙用呢？我想聪明的你已经想出了答案。</p>
]]></content>
      <categories>
        <category>Command</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>什么是 quicksort</title>
    <url>/2021/08/28/%E4%BB%80%E4%B9%88%E6%98%AF-quicksort/</url>
    <content><![CDATA[<p><em><code>Quick</code></em> -&gt; <code>快</code><br><em><code>Sort</code></em> -&gt; <code>排序</code></p>
<p>所以 QuickSort 就是快速的排序。本章终。</p>
<p>哈哈哈，开个小玩笑，我们言归正传。</p>
<a id="more"></a>

<h2 id="1-快从何来"><a href="#1-快从何来" class="headerlink" title="1. 快从何来"></a>1. 快从何来</h2><p>在谈快之前，我想我们要先明白排序是什么，有快就有慢，那么为什么别的是慢的？</p>
<p>实际上，Donald E.Knuth 已经在《TAOCP》卷三中提到了排序的思想。甚至介绍了几十种排序方式。而我们简单写个笔记，排序的本质应用：</p>
<blockquote>
<ol>
<li>求解“归属”问题</li>
<li>匹配两个或更多文件中的项目</li>
<li>按键值查找信息</li>
</ol>
</blockquote>
<p>接下来让我们着重看快速排序吧。</p>
<p>快速排序使用每次比较的结果来确认接下来要比较哪些 key。基本思想：</p>
<blockquote>
<ol>
<li>任意取得一条记录 R(x)，将其移动到有序文件中它应当占据的最终位置（FinalPosition下面简记为 FP）该标记记录为 R(FP)。</li>
<li>在确定最终位置的同时，重新安排其他记录（Record），使得 R(FP) 的左侧没有更大的记录，右侧没有更小的记录。</li>
<li>再次回到第一个记录。继续下面的步骤，知道最终完成所有记录的排序。</li>
</ol>
</blockquote>
<p>这样，原来的排序方式简化为两个简单问题，也就是分别对 R(1)…R(FP-1) 和 R(FP+1)…R(N) 进行独立排序。</p>
<p><strong>平均时间复杂度：nlogn 且常数因子 n 小于归并排序。</strong></p>
<p>可能看完思想后觉得非常简单，但是实际上废话一堆。因为，R(x) 是第几个记录？凭什么能一下子就将其移动到它应当占据的最终位置 R(FP)？</p>
<p>Ok，请先不要失望，也不要做抬杠精英。让我们来实现一下。</p>
<h2 id="2-实现"><a href="#2-实现" class="headerlink" title="2. 实现"></a>2. 实现</h2><p>我们先看一下关于思想里面的话题来写一个实现。</p>
<ul>
<li>quicksort 函数基本思想很简单，先传入一个 int 型数组，然后传入当前数组的左边界下标和右边界下标。然后该函数返回一个在正确位置的记录的下标。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quicksort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &lt; right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        此时就完成了思路中的第一条：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        任意取得一条记录 R(x)，将其移动到有序文件中它应当占据的最终位置（FinalPosition下面简记为 FP）该标记记录为 R(FP)</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">        在此段程序中，我们向 partition 函数传入了：</span></span><br><span class="line"><span class="comment">         1. 待排序的 int 型数组 A;</span></span><br><span class="line"><span class="comment">         2. 数组 A 待排序部分左边界的值 left;</span></span><br><span class="line"><span class="comment">         3. 数组 A 待排序部分右边界的值 right;</span></span><br><span class="line"><span class="comment">         </span></span><br><span class="line"><span class="comment">        partition 返回了一个 int 型数字，这个数字目前已经在 A 的正确位置了。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">int</span> pivot = partition(A, left, right);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 接下来，我们将待排序部分 [left, right] 转变为了 [left, pivot)</span></span><br><span class="line">        <span class="comment">// 先对 数组 A 的 left 到 pivot 左边的值再次进行排序</span></span><br><span class="line">        quicksort(A, left, pivot - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当 quicksort(A, left, pivot - 1); 执行完成后，我们可以确认</span></span><br><span class="line">        <span class="comment">// 排好了 [left, pivot) 和 pivot 这两个部分的数组值。此时排好序范围为：</span></span><br><span class="line">        <span class="comment">// [left, pivot]</span></span><br><span class="line">        <span class="comment">// 接下来，我们将待排序部分只剩下了 (pivot, right]</span></span><br><span class="line">        <span class="comment">// 所以，A 中待排序数字</span></span><br><span class="line">        <span class="comment">// 左边界是 pivot + 1</span></span><br><span class="line">        <span class="comment">// 有边界是 right</span></span><br><span class="line">        quicksort(A, pivot + <span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>接下来是我们分治核心 partition 的实现：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span> *A, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 我们选取数组 A 的最左边界值作为第一个被排序数字。</span></span><br><span class="line">    <span class="keyword">int</span> pivot = A[left];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此时成立</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt; right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 先检查右边界：</span></span><br><span class="line">        <span class="comment">// 最右值大于 待排序值</span></span><br><span class="line">        <span class="comment">// 且下标 left &lt; right</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right &amp;&amp; A[right] &gt;= pivot)</span><br><span class="line">            <span class="comment">// 判断右边界的前一个</span></span><br><span class="line">            --right;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当不满足前面的条件，即 right 下标对应的值小于 待排序记录的值，</span></span><br><span class="line">        <span class="comment">// 将 right 下标的值赋值到 left 下标。</span></span><br><span class="line">        A[left] = A[right];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查看左边界：</span></span><br><span class="line">        <span class="comment">// 最右值大于 待排序值</span></span><br><span class="line">        <span class="comment">// 且下标 left &lt; right</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right &amp;&amp; A[left] &lt;= pivot)</span><br><span class="line">            <span class="comment">// 判断左边界的后一个</span></span><br><span class="line">            left++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当不满足前面的条件，即 left 下标对应的值大于 待排序记录的值，</span></span><br><span class="line">        <span class="comment">// 将 left 下标的值赋值到 right 下标。</span></span><br><span class="line">        A[right] = A[left];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此时的 left 已经被移动，并且现在 left 所在的下标</span></span><br><span class="line">    <span class="comment">// 就 pivot 这个值应该在的当前数组待排序区间的正确位置。</span></span><br><span class="line">    A[left] = pivot;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回这个正确的下标位置。</span></span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><p>快排，听起来简单，实际上实现起来全是需要注意的细节点和优化点．</p>
<p>而且，在 CPP 中有一种方法叫 Inline(内连函数). 而我们当前的实现是递归的方式, 并不能充分的利用这一特性.</p>
<p>那么应该如何做到这一点呢???</p>
]]></content>
  </entry>
  <entry>
    <title>用 OceanBase 实现 Hello World</title>
    <url>/2021/09/04/%E7%94%A8-OceanBase-%E5%AE%9E%E7%8E%B0-Hello-World/</url>
    <content><![CDATA[<p>首先我们来看一下什么是 <code>OceanBase</code>, 下面是来自官方的定义:</p>
<blockquote>
<p><a href="https://github.com/oceanbase/oceanbase" target="_blank" rel="noopener">OceanBase</a> 社区版是一款开源分布式 HTAP（Hybrid Transactional/Analytical Processing）数据库管理系统，具有原生分布式架构，支持金融级高可用、透明水平扩展、分布式事务、多租户和语法兼容等企业级特性。OceanBase 内核通过大规模商用场景的考验，已服务众多行业客户，现面向未来持续构建内核技术竞争力。</p>
</blockquote>
<p>而作为一个数据库疯狂热爱者，在看到它的那一刻直接下载了一份源码。而在经过一番折腾之后，终于让 OceanBase 老老实实的说了一句 Hello World。接下来跟大家分享一下我是如何做到的。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&gt; SELECT 'Hello World';</span><br></pre></td></tr></table></figure>

<p>本章完~ 哈哈，开个小玩笑。接下来让我们进入正文。</p>
<h2 id="1-如何向-OceanBase-贡献代码"><a href="#1-如何向-OceanBase-贡献代码" class="headerlink" title="1. 如何向 OceanBase 贡献代码"></a>1. 如何向 OceanBase 贡献代码</h2><a id="more"></a>

<p>众所周知，OB 在 2021 年儿童节宣布开源。或许准备稍有仓促导致很多文档介绍都没有跟上，因此如果希望给 OB 贡献代码相对就比较困难了。</p>
<p>而函数部分功能目前看来并不是特别多，大家还是有机会从这一块入手并且向着 PMC 前进的。而作为项目启动的第一步，我们依然沿袭各个语言的经典项目 <code>Hello World</code>。</p>
<p>那么，我们就开始不那么正式的给 OB 实现一个 hello_world() 函数吧。借此来熟悉一些 SQL 相关的模块。</p>
<h3 id="1-1-代码模块"><a href="#1-1-代码模块" class="headerlink" title="1.1. 代码模块"></a>1.1. 代码模块</h3><p> OB 作为一个分布式数据库，代码结构是较为庞大的。而我们需要的就是抽丝剥茧的能力，摒弃掉无关部分，找到我们需要的几个目录和文件。</p>
<p>熟悉 MySQL 的朋友应该都比较了解：如果需要向 MySQL 支持一个函数或者找一下某个已有函数的源码实现，需要去 <a href="https://github.com/mysql/mysql-server/blob/8.0/sql/item_create.h" target="_blank" rel="noopener">item_create.h</a> &amp; <a href="https://github.com/mysql/mysql-server/blob/8.0/sql/item_create.cc" target="_blank" rel="noopener">item_create.cpp</a> 找它的原生定义。</p>
<p>而 OB 同样有类似的门户，在 OB 中严格的按照 SQL 的生命周期命名了目录。因此，我们会看到这样的结构。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">➜  ~&#x2F;database&#x2F;source-code&#x2F;oceanbase👆 git:(hello_world) ⚡ tree -L 1 -d src&#x2F;sql</span><br><span class="line">src&#x2F;sql</span><br><span class="line">├── CMakeFiles</span><br><span class="line">├── code_generator</span><br><span class="line">├── dtl</span><br><span class="line">├── engine</span><br><span class="line">├── executor</span><br><span class="line">├── monitor</span><br><span class="line">├── optimizer</span><br><span class="line">├── parser</span><br><span class="line">├── plan_cache</span><br><span class="line">├── privilege_check</span><br><span class="line">├── resolver</span><br><span class="line">├── rewrite</span><br><span class="line">└── session</span><br><span class="line"></span><br><span class="line">13 directories</span><br></pre></td></tr></table></figure>

<p>我们这次要修改的主体部分在 <a href="https://github.com/oceanbase/oceanbase/tree/master/src/sql/engine" target="_blank" rel="noopener">engine</a>目录中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">➜  ~&#x2F;database&#x2F;source-code&#x2F;oceanbase👆 git:(hello_world) ⚡ tree -L 1 -d src&#x2F;sql&#x2F;engine </span><br><span class="line"></span><br><span class="line">src&#x2F;sql&#x2F;engine</span><br><span class="line">├── aggregate</span><br><span class="line">├── basic</span><br><span class="line">├── cmd</span><br><span class="line">├── connect_by</span><br><span class="line">├── dml</span><br><span class="line">├── expr</span><br><span class="line">├── join</span><br><span class="line">├── pdml</span><br><span class="line">├── prepare</span><br><span class="line">├── px</span><br><span class="line">├── recursive_cte</span><br><span class="line">├── sequence</span><br><span class="line">├── set</span><br><span class="line">├── sort</span><br><span class="line">├── subquery</span><br><span class="line">├── table</span><br><span class="line">├── user_defined_function</span><br><span class="line">└── window_function</span><br><span class="line"></span><br><span class="line">18 directories</span><br></pre></td></tr></table></figure>

<p>直到这里，我们还是没有看到熟悉的 func。不要着急，因为在 OB 眼中所有的函数本质都是表达式。因此，他将其命名为 <a href="https://github.com/oceanbase/oceanbase/tree/master/src/sql/engine/expr" target="_blank" rel="noopener">expr</a>。<br>举个现成的例子，比如我们都熟悉的 abs() 函数，就安安静静的在 expr 目录中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">➜  ~&#x2F;database&#x2F;source-code&#x2F;oceanbase&#x2F;src&#x2F;sql&#x2F;engine&#x2F;expr👆 git:(hello_world) ⚡ ls |grep ob_expr_abs.cpp</span><br><span class="line">ob_expr_abs.cpp</span><br></pre></td></tr></table></figure>

<p>因此，我们确实找到了 <code>expr(表达式)</code> 的老巢。而接下来要做的就是搭一个架子出来，这个架子能够嵌入到 OB 目前已有的支持 expr 框架中。简单来说就是让 OB 能够认识函数的名字。下面是一些简单的介绍:</p>
<blockquote>
<ul>
<li><a href="https://github.com/oceanbase/oceanbase/blob/master/src/sql/CMakeLists.txt" target="_blank" rel="noopener">src/sql/CMakeLists.txt</a> : 它是那么的明显以至于我都无法忽视它的存在。</li>
<li><a href="https://github.com/oceanbase/oceanbase/blob/master/src/sql/parser/ob_item_type.h" target="_blank" rel="noopener">src/sql/parser/ob_item_type.h</a> : 当一条 SQL 通过了词法解析，获取每个 TOKEN 后，parser 层就需要做一些工作, 因此, 我们需要去 parser 目录中找一下有没有对应的文件, 经过一番筛选，确认是它。因为在<a href="https://github.com/oceanbase/oceanbase/blob/master/src/sql/parser/ob_item_type.h#L417" target="_blank" rel="noopener">该行注释</a>中已经非常清晰的告知了我们他的用途。</li>
<li><a href="https://github.com/oceanbase/oceanbase/blob/master/src/sql/engine/expr/ob_expr_eval_functions.cpp" target="_blank" rel="noopener">src/sql/engine/expr/ob_expr_eval_functions.cpp</a> : 在之前的一些分享中已经有提到，OB 有新老 SQL 引擎的区分，而如果需要注册成为新引擎能识别的 expr 则需要在<a href="https://github.com/oceanbase/oceanbase/blob/master/src/sql/engine/expr/ob_expr_eval_functions.cpp#L260" target="_blank" rel="noopener">g_expr_eval_functions</a> 数组中进行 append。</li>
<li><a href="https://github.com/oceanbase/oceanbase/blob/master/deps/oblib/src/lib/ob_name_def.h" target="_blank" rel="noopener">deps/oblib/src/lib/ob_name_def.h</a> : 这里面定义的是所有的关键字, 函数等等, 所有可以被日志使用的宏定义。还是以我们熟悉的 abs() 为例子，他就那么不显山不漏水的躺在<a href="https://github.com/oceanbase/oceanbase/blob/master/deps/oblib/src/lib/ob_name_def.h#L363" target="_blank" rel="noopener">这里</a>。</li>
<li><a href="https://github.com/oceanbase/oceanbase/blob/master/src/sql/engine/expr/ob_expr_operator_factory.cpp" target="_blank" rel="noopener">src/sql/engine/expr/ob_expr_operator_factory.cpp</a> : 从文件命名来看，是所有 表达式算子（expr operator）的工厂，所以，理论上需要在这里注册函数，被 OB 所识别。从 <a href="https://github.com/oceanbase/oceanbase/blob/master/src/sql/engine/expr/ob_expr_operator_factory.cpp#L414" target="_blank" rel="noopener">这里</a> 的注释可以看到更详细的信息。</li>
</ul>
</blockquote>
<p><strong>注意:</strong><br>核心改动在于:</p>
<blockquote>
<ul>
<li><a href="https://github.com/oceanbase/oceanbase/blob/master/src/sql/CMakeLists.txt" target="_blank" rel="noopener">src/sql/CMakeLists.txt</a></li>
<li><a href="https://github.com/oceanbase/oceanbase/blob/master/src/sql/parser/ob_item_type.h" target="_blank" rel="noopener">src/sql/parser/ob_item_type.h</a></li>
<li><a href="https://github.com/oceanbase/oceanbase/blob/master/src/sql/engine/expr/ob_expr_eval_functions.cpp" target="_blank" rel="noopener">src/sql/engine/expr/ob_expr_eval_functions.cpp</a></li>
<li><a href="https://github.com/oceanbase/oceanbase/blob/master/deps/oblib/src/lib/ob_name_def.h" target="_blank" rel="noopener">deps/oblib/src/lib/ob_name_def.h</a></li>
<li><a href="https://github.com/oceanbase/oceanbase/blob/master/src/sql/engine/expr/ob_expr_operator_factory.cpp" target="_blank" rel="noopener">src/sql/engine/expr/ob_expr_operator_factory.cpp</a></li>
<li><a href="https://github.com/oceanbase/oceanbase/tree/master/src/sql/engine/expr" target="_blank" rel="noopener">src/sql/engine/expr</a></li>
</ul>
</blockquote>
<h2 id="2-Just-Do-It"><a href="#2-Just-Do-It" class="headerlink" title="2. Just Do It"></a>2. Just Do It</h2><p>我们直接在 <a href="https://github.com/oceanbase/oceanbase/tree/master/src/sql/engine/expr" target="_blank" rel="noopener">src/sql/engine/expr</a> 中增加一组 C++ Class <code>ob_expr_hello</code></p>
<p>因为本函数希望实现形式是:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HELLO_WORLD()</span><br></pre></td></tr></table></figure>

<p>可以确定这是一个入参为 0 且返回值类型为 String 的表达式. 因此, 我们进一步确定头文件中只需要这些函数, 并且作为 <a href="https://github.com/oceanbase/oceanbase/blob/master/src/sql/engine/expr/ob_expr_operator.h#L1452" target="_blank" rel="noopener">ObStringExprOperator</a> 的子类:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ObExprHELLO</span> :</span> <span class="keyword">public</span> ObStringExprOperator &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">ObExprHELLO</span><span class="params">(common::ObIAllocator&amp; alloc)</span></span>;</span><br><span class="line">  <span class="keyword">virtual</span> ~ObExprHELLO();</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">calc_result_type0</span><span class="params">(ObExprResType&amp; type, common::ObExprTypeCtx&amp; type_ctx)</span> <span class="keyword">const</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">calc_result0</span><span class="params">(common::ObObj&amp; result, common::ObExprCtx&amp; expr_ctx)</span> <span class="keyword">const</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">eval_hello</span><span class="params">(<span class="keyword">const</span> ObExpr&amp; expr, ObEvalCtx&amp; ctx, ObDatum&amp; expr_datum)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">cg_expr</span><span class="params">(ObExprCGCtx&amp; op_cg_ctx, <span class="keyword">const</span> ObRawExpr&amp; raw_expr, ObExpr&amp; rt_expr)</span> <span class="keyword">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  DISALLOW_COPY_AND_ASSIGN(ObExprHELLO);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="3-来吧展示"><a href="#3-来吧展示" class="headerlink" title="3. 来吧展示"></a>3. 来吧展示</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">&gt;select HELLO_WORLD();</span><br><span class="line">+<span class="comment">---------------+</span></span><br><span class="line">| HELLO_WORLD() |</span><br><span class="line">+<span class="comment">---------------+</span></span><br><span class="line">| Hello World~  |</span><br><span class="line">+<span class="comment">---------------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>


<h2 id="4-测试"><a href="#4-测试" class="headerlink" title="4. 测试"></a>4. 测试</h2><p>OB 的测试和 MySQL 的 mtr 测试基本一致。位于：</p>
<p><a href="https://github.com/oceanbase/oceanbase/blob/master/test/mysql_test/test_suite/expr/t/" target="_blank" rel="noopener">https://github.com/oceanbase/oceanbase/blob/master/test/mysql_test/test_suite/expr/t/</a><br><a href="https://github.com/oceanbase/oceanbase/tree/master/test/mysql_test/test_suite/expr/r/mysql" target="_blank" rel="noopener">https://github.com/oceanbase/oceanbase/tree/master/test/mysql_test/test_suite/expr/r/mysql</a></p>
<p>可以在本次的 commit 中查看整体代码。</p>
<h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><p>整体来看，一个表达式的书写没有那么复杂。</p>
<blockquote>
<ol>
<li>可以被编译。</li>
<li>可以被 OB 识别。</li>
<li>实现 expr 内部逻辑。</li>
</ol>
</blockquote>
<p>在这里附上 <a href="https://github.com/TCeason/oceanbase/commit/ba3d88ccbf01d4c7dc77d3cff7e1c07485d2f041" target="_blank" rel="noopener">完整代码</a> 感兴趣的朋友可以看一看，也欢迎给 <a href="https://github.com/oceanbase/oceanbase" target="_blank" rel="noopener">OB</a> 点 Star 哦。</p>
]]></content>
      <categories>
        <category>Database</category>
      </categories>
  </entry>
</search>
